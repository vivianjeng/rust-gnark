//! Integration tests for rust-gnark Groth16 BN254 prove/verify roundtrip.
//!
//! Uses pre-generated test vectors from a simple cubic circuit (x^3 + x + 5 == y, with x=3, y=35).
//! Test vectors are generated by `go/cmd/gen_test_vectors/main.go`.

#[cfg(test)]
mod tests {
    use anyhow::Result;
    use rust_gnark::{groth16_prove, groth16_verify, init};

    const R1CS_PATH: &str = "./test-vectors/cubic_circuit.r1cs";
    const PK_PATH: &str = "./test-vectors/cubic_circuit.pk";
    const VK_PATH: &str = "./test-vectors/cubic_circuit.vk";

    /// Test: Groth16 BN254 prove + verify roundtrip.
    ///
    /// Circuit: x^3 + x + 5 == y (with x=3, y=35)
    #[test]
    fn test_groth16_prove_verify_roundtrip() -> Result<()> {
        init()?;

        // x=3: x^3 + x + 5 = 27 + 3 + 5 = 35
        let witness_json = r#"{"X": "3", "Y": "35"}"#;

        let proof_result = groth16_prove(R1CS_PATH, PK_PATH, witness_json)?;

        assert!(!proof_result.proof.is_empty(), "Proof should not be empty");
        assert!(
            !proof_result.public_inputs.is_empty(),
            "Public inputs should not be empty"
        );

        let valid = groth16_verify(R1CS_PATH, VK_PATH, &proof_result)?;
        assert!(valid, "Proof should be valid");

        Ok(())
    }

    /// Test: Verification rejects a tampered proof.
    #[test]
    fn test_groth16_verify_rejects_tampered_proof() -> Result<()> {
        init()?;

        let witness_json = r#"{"X": "3", "Y": "35"}"#;
        let mut proof_result = groth16_prove(R1CS_PATH, PK_PATH, witness_json)?;

        let mut chars: Vec<char> = proof_result.proof.chars().collect();
        if chars.len() > 10 {
            chars[10] = if chars[10] == 'a' { 'b' } else { 'a' };
        }
        proof_result.proof = chars.into_iter().collect();

        // Verification should fail (either invalid proof or deserialization error)
        let result = groth16_verify(R1CS_PATH, VK_PATH, &proof_result);
        if let Ok(valid) = result {
            assert!(!valid, "Tampered proof should not be valid");
        }
        // Err is also acceptable (deserialization error from corrupted proof bytes)

        Ok(())
    }
}
