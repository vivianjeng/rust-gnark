//! Rust bindings for gnark Groth16 BN254 prover/verifier.
//!
//! This crate provides safe Rust wrappers around the gnark Go library, compiled
//! via CGO into a static C archive. The bindings are auto-generated by `bindgen`
//! from the C header produced by `go build -buildmode=c-archive`.
//!
//! # Supported platforms
//!
//! - aarch64-apple-ios
//! - aarch64-apple-ios-sim
//! - x86_64-apple-ios
//! - aarch64-apple-darwin
//! - x86_64-apple-darwin
//! - aarch64-linux-android
//! - x86_64-linux-android
//! - x86_64-unknown-linux-gnu
//! - aarch64-unknown-linux-gnu
//!
//! # Note
//!
//! WASM is **not** supported because `c-archive` does not target WASM.

use anyhow::{bail, Result};
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

// Suppress warnings on bindgen-generated code (doesn't follow Rust conventions).
#[allow(warnings, clippy::all)]
mod bind {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// Result of a Groth16 BN254 proof generation.
///
/// Both fields are hex-encoded binary serializations from gnark:
/// - `proof`: the compressed Groth16 proof (via `proof.WriteTo()`)
/// - `public_inputs`: the public witness (via `witness.MarshalBinary()`)
#[derive(Debug, Clone)]
pub struct Groth16ProofResult {
    /// Hex-encoded gnark binary proof.
    pub proof: String,
    /// Hex-encoded gnark binary public witness.
    pub public_inputs: String,
}

/// Initialize the gnark Go runtime.
///
/// Sets `GODEBUG=asyncpreemptoff=1` on iOS/macOS to prevent signal flood crashes
/// in debug builds. Call once before any prove/verify operations.
///
/// # Errors
///
/// Returns an error if the Go runtime initialization fails.
pub fn init() -> Result<()> {
    let ret = unsafe { bind::gnark_init() };
    if ret != 0 {
        bail!("gnark_init failed with code {ret}");
    }
    Ok(())
}

/// Generate a Groth16 BN254 proof.
///
/// # Arguments
///
/// * `r1cs_path` - Path to the `.r1cs` file (CBOR binary format)
/// * `pk_path` - Path to the `.pk` file (gnark binary, loaded via `UnsafeReadFrom` for speed)
/// * `witness_json` - JSON object mapping circuit field names to decimal string values,
///   e.g. `{"A": "3", "B": "5"}`
///
/// # Returns
///
/// A [`Groth16ProofResult`] containing hex-encoded proof and public inputs.
///
/// # Errors
///
/// Returns an error if file loading, witness construction, or proof generation fails.
pub fn groth16_prove(
    r1cs_path: &str,
    pk_path: &str,
    witness_json: &str,
) -> Result<Groth16ProofResult> {
    let r1cs = CString::new(r1cs_path)?;
    let pk = CString::new(pk_path)?;
    let witness = CString::new(witness_json)?;

    let result = unsafe {
        bind::gnark_groth16_prove(
            r1cs.as_ptr() as *mut c_char,
            pk.as_ptr() as *mut c_char,
            witness.as_ptr() as *mut c_char,
        )
    };

    if result.is_null() {
        bail!("gnark_groth16_prove returned null");
    }

    unsafe {
        let out = if (*result).error.is_null() {
            let proof_ptr = (*result).proof;
            let pub_ptr = (*result).public_inputs;

            if proof_ptr.is_null() || pub_ptr.is_null() {
                Err(anyhow::anyhow!(
                    "gnark_groth16_prove: proof or public_inputs pointer is null"
                ))
            } else {
                Ok(Groth16ProofResult {
                    proof: CStr::from_ptr(proof_ptr).to_string_lossy().into_owned(),
                    public_inputs: CStr::from_ptr(pub_ptr).to_string_lossy().into_owned(),
                })
            }
        } else {
            let err = CStr::from_ptr((*result).error)
                .to_string_lossy()
                .into_owned();
            Err(anyhow::anyhow!("Proof generation failed: {err}"))
        };

        bind::gnark_free_proof_result(result);
        out
    }
}

/// Verify a Groth16 BN254 proof.
///
/// # Arguments
///
/// * `r1cs_path` - Path to the `.r1cs` file
/// * `vk_path` - Path to the `.vk` file (gnark binary, loaded via `ReadFrom`)
/// * `proof_result` - The proof result from [`groth16_prove`]
///
/// # Returns
///
/// `Ok(true)` if the proof is valid, `Ok(false)` if the proof is invalid,
/// or `Err` on verification errors unrelated to proof validity.
///
/// # Errors
///
/// Returns an error if file loading or deserialization fails.
pub fn groth16_verify(
    r1cs_path: &str,
    vk_path: &str,
    proof_result: &Groth16ProofResult,
) -> Result<bool> {
    let r1cs = CString::new(r1cs_path)?;
    let vk = CString::new(vk_path)?;
    let proof = CString::new(proof_result.proof.as_str())?;
    let pub_inputs = CString::new(proof_result.public_inputs.as_str())?;

    let err_ptr = unsafe {
        bind::gnark_groth16_verify(
            r1cs.as_ptr() as *mut c_char,
            vk.as_ptr() as *mut c_char,
            proof.as_ptr() as *mut c_char,
            pub_inputs.as_ptr() as *mut c_char,
        )
    };

    if err_ptr.is_null() {
        // NULL = valid proof
        Ok(true)
    } else {
        let err = unsafe {
            let s = CStr::from_ptr(err_ptr).to_string_lossy().into_owned();
            bind::gnark_free_string(err_ptr);
            s
        };
        if err.contains("invalid proof") {
            Ok(false)
        } else {
            bail!("Verification error: {err}")
        }
    }
}
